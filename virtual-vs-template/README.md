# Virtual Functions vs Templates: Runtime vs Compile-Time Polymorphism

A comprehensive comparison of C++ polymorphism mechanisms with detailed explanations of how vtables work and performance characteristics.

## Overview

This directory demonstrates two fundamental approaches to polymorphism in C++:

1. **Virtual Functions**: Runtime polymorphism via vtables
2. **Templates**: Compile-time polymorphism via code generation

## Files

- `01_virtual_polymorphism.cpp` - Virtual functions with detailed vtable explanation
- `02_template_polymorphism.cpp` - Templates with compile-time code generation
- `03_performance_comparison.cpp` - Head-to-head performance benchmarks

## Quick Start

```bash
cd virtual-vs-template

# Compile and run all examples
g++ -std=c++17 -O2 01_virtual_polymorphism.cpp -o virtual && ./virtual
g++ -std=c++17 -O2 02_template_polymorphism.cpp -o template && ./template
g++ -std=c++17 -O2 03_performance_comparison.cpp -o benchmark && ./benchmark
```

## How Vtables Work

### Virtual Function Call Mechanism

When you have a class with virtual functions:

```cpp
class Animal {
    virtual void speak() = 0;
};

class Dog : public Animal {
    void speak() override { std::cout << "Woof\n"; }
};
```

**Memory Layout:**

```
Object in Memory:
+------------------+
| vptr (hidden)    | --> Points to vtable
+------------------+
| data members     |
+------------------+

Vtable for Dog:
+------------------+
| &Dog::speak      | --> Function pointer
| &Dog::move       | --> Function pointer
+------------------+
```

**Call Process:**

```cpp
Animal* animal = new Dog();
animal->speak();  // Virtual call
```

1. Follow `vptr` to find vtable
2. Look up `speak()` entry in vtable  
3. Indirect jump to function address

**Assembly pseudocode:**
```asm
mov rax, [animal]    ; Get vptr
mov rbx, [rax]       ; Get first vtable entry
call rbx             ; Indirect call
```

### Cost of Virtual Functions

- **2 pointer dereferences** per call
- **Cannot be inlined** by compiler
- **Memory overhead**: vptr per object (8 bytes on 64-bit)
- **Cache unfriendly**: vtable lookups

## How Templates Work

### Template Instantiation

Templates are resolved at compile time:

```cpp
template<typename T>
void makeAnimalSpeak(const T& animal) {
    animal.speak();
}

makeAnimalSpeak(dog);  // T = Dog
makeAnimalSpeak(cat);  // T = Cat
```

**Compiler generates TWO separate functions:**

```cpp
// Generated by compiler
void makeAnimalSpeak_Dog(const Dog& animal) {
    animal.speak();  // Direct call to Dog::speak()
}

void makeAnimalSpeak_Cat(const Cat& animal) {
    animal.speak();  // Direct call to Cat::speak()
}
```

**Call Process:**

```asm
call Dog::speak    ; DIRECT call - can be inlined!
```

### Benefits of Templates

- **Zero runtime overhead**: Direct function calls
- **Full inlining**: Compiler can optimize aggressively
- **No memory overhead**: No vptr needed
- **Duck typing**: No inheritance required

### Cost of Templates

- **Code bloat**: Separate copy for each type
- **Longer compile times**: More code to generate
- **Compile-time only**: Type must be known at compile time

## Performance Comparison

Expected results from `03_performance_comparison.cpp`:

### Single Call Performance

```
Virtual function:
  Time: ~150 ms
  Per call: ~1.5 ns

Template function:
  Time: ~50 ms  (3x faster)
  Per call: ~0.5 ns
```

### Memory Overhead

```
For 1,000,000 objects:
  Virtual: 8,000 KB (with vptr)
  Template: 0 KB (no vptr)
  Extra memory: 7,812 KB
```

## When to Use Each

### Use Virtual Functions When:

✓ You need **runtime type selection**
```cpp
Animal* animal = userChoice == 1 ? new Dog() : new Cat();
```

✓ You want to store **different types in the same container**
```cpp
std::vector<std::unique_ptr<Animal>> zoo;
zoo.push_back(std::make_unique<Dog>());
zoo.push_back(std::make_unique<Cat>());
```

✓ You're building a **plugin system** or **framework**

✓ **Binary size** is more important than performance

### Use Templates When:

✓ **Type is known at compile time**

✓ **Performance is critical** (hot paths, tight loops)

✓ You want **zero-cost abstraction**

✓ You need **compile-time guarantees**

✓ **Memory overhead matters** (millions of objects)

## Comparison Table

| Aspect | Virtual Functions | Templates |
|--------|------------------|-----------|
| **Resolution** | Runtime | Compile-time |
| **Mechanism** | Vtable lookup | Code generation |
| **Call overhead** | 2 pointer dereferences | Direct call (often inlined) |
| **Memory per object** | +8 bytes (vptr) | 0 bytes |
| **Binary size** | Smaller | Larger (code duplication) |
| **Compile time** | Fast | Slower |
| **Heterogeneous container** | ✓ Yes | ✗ No (need std::variant) |
| **Runtime type selection** | ✓ Yes | ✗ No |
| **Inlining** | ✗ No | ✓ Yes |
| **Cache efficiency** | Worse (vtable lookups) | Better (direct calls) |

## Real-World Use Cases

### Virtual Functions

- **GUI frameworks**: Qt, wxWidgets (widgets polymorphic)
- **Game engines**: Component systems, entity hierarchies
- **Plugin architectures**: Loading types at runtime
- **Abstract interfaces**: Database drivers, file systems

### Templates

- **STL containers**: `std::vector<T>`, `std::map<K, V>`
- **Algorithms**: `std::sort`, `std::find`
- **Expression templates**: Eigen, Blaze (linear algebra)
- **Policy-based design**: Custom allocators, comparators

## Hybrid Approaches

You can combine both:

```cpp
// Virtual interface for runtime polymorphism
class IProcessor {
    virtual void process() = 0;
};

// Template implementation for performance
template<typename DataType>
class Processor : public IProcessor {
    void process() override {
        // Fast template code here
    }
};
```

This gives you:
- Virtual interface for flexibility
- Template implementation for performance

## Key Takeaways

1. **Virtual functions** use vtables for runtime dispatch
   - Each object has hidden vptr
   - Vtable contains function pointers
   - 2 pointer dereferences per call

2. **Templates** generate code at compile time
   - Separate function for each type
   - Direct calls, no indirection
   - Can be fully inlined

3. **Performance**: Templates are typically 2-3x faster
   - But only when type is known at compile time

4. **Flexibility**: Virtual functions more flexible
   - Runtime type selection
   - Heterogeneous containers

5. **Binary size**: Virtual functions produce smaller binaries
   - One function serves all types
   - Templates duplicate code for each type

## Further Reading

- [C++ Vtables - Part 1](https://pabloariasal.github.io/2017/06/10/understanding-virtual-tables/)
- [Template Metaprogramming](https://en.cppreference.com/w/cpp/language/templates)
- [Modern C++ Design](https://en.wikipedia.org/wiki/Modern_C%2B%2B_Design) by Andrei Alexandrescu
- [Effective C++](https://www.aristeia.com/books.html) by Scott Meyers (Item 41: Understand implicit interfaces and compile-time polymorphism)

## Interview Questions

This directory helps you answer:

1. **How do vtables work in C++?**
   - See `01_virtual_polymorphism.cpp` for detailed explanation

2. **What's the performance difference between virtual functions and templates?**
   - See `03_performance_comparison.cpp` for benchmarks

3. **When should you use templates vs virtual functions?**
   - See comparison table and use cases above

4. **What's the memory overhead of virtual functions?**
   - 8 bytes per object (vptr) + vtable size per class

5. **Can templates be as flexible as virtual functions?**
   - No - type must be known at compile time
   - But `std::variant` can help bridge the gap
